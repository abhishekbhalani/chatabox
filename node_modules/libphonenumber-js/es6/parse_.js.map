{"version":3,"sources":["../source/parse_.js"],"names":["VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","matchesEntirely","ParseError","Metadata","isViablePhoneNumber","extractExtension","parseIncompletePhoneNumber","getCountryCallingCode","getNumberType","checkNumberLengthForType","isPossibleNumber","stripIDDPrefix","parseRFC3966","PhoneNumber","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","AFTER_PHONE_NUMBER_END_PATTERN","parse","text","options","metadata","defaultCountry","hasCountry","v2","Error","parseInput","formattedPhoneNumber","number","ext","parsePhoneNumber","defaultCallingCode","country","nationalNumber","countryCallingCode","carrierCode","hasSelectedNumberingPlan","length","phoneNumber","valid","nationalNumberPattern","extended","result","possible","possibleLengths","undefined","phone","extractFormattedPhoneNumber","startsAt","search","slice","replace","stripNationalPrefixAndCarrierCode","nationalPrefixForParsing","prefixPattern","prefixMatch","exec","nationalSignificantNumber","capturedGroupsCount","nationalPrefixTransformRule","nationalPrefix","findCountryCode","callingCode","nationalPhoneNumber","isNonGeographicCallingCode","possibleCountries","getCountryCodesForCallingCode","_findCountryCode","leadingDigits","indexOf","with_extension_stripped","national_number","extractCountryCallingCode","chooseCountryByCountryCallingCode","selectNumberingPlan","parseNationalNumber","exactCountry","potentialNationalNumber","potentialCarrierCode","numberWithoutIDD","i","hasCallingCode"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './isViablePhoneNumber'\r\nimport { extractExtension } from './extension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport getNumberType, { checkNumberLengthForType } from './getNumberType_'\r\nimport { isPossibleNumber } from './isPossibleNumber_'\r\nimport { stripIDDPrefix } from './IDD'\r\nimport { parseRFC3966 } from './RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parseInput(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (options.extended === true) && metadata.possibleLengths() && isPossibleNumber(nationalNumber, countryCallingCode !== undefined, metadata),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nexport function extractFormattedPhoneNumber(text, v2) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * Strips any national prefix (such as 0, 1) present in the number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ number, carrierCode }`.\r\n */\r\nexport function stripNationalPrefixAndCarrierCode(number, metadata) {\r\n\tif (!number) {\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tif (!metadata.nationalPrefixForParsing()) {\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// See METADATA.md for the description of\r\n\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\r\n\t// Attempt to parse the first digits as a national prefix.\r\n\tconst prefixPattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst prefixMatch = prefixPattern.exec(number)\r\n\r\n\tif (!prefixMatch) {\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tlet nationalSignificantNumber\r\n\tlet carrierCode\r\n\r\n\t// If a \"capturing group\" didn't match\r\n\t// then its element in `prefixMatch[]` array will be `undefined`.\r\n\r\n\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\tif (metadata.nationalPrefixTransformRule() &&\r\n\t\tcapturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]) {\r\n\t\tnationalSignificantNumber = number.replace(\r\n\t\t\tprefixPattern,\r\n\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t)\r\n\t\t// Carrier code is the last captured group,\r\n\t\t// but only when there's more than one captured group.\r\n\t\tif (capturedGroupsCount > 1 && prefixMatch[capturedGroupsCount]) {\r\n\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t}\r\n\t}\r\n\t// If it's a simple-enough case then just\r\n\t// strip the national prefix from the number.\r\n\telse {\r\n\t\t// National prefix is the whole substring matched by\r\n\t\t// the `national_prefix_for_parsing` regexp.\r\n\t\tconst nationalPrefix = prefixMatch[0]\r\n\t\tnationalSignificantNumber = number.slice(nationalPrefix.length)\r\n\t\t// Carrier code is the last captured group.\r\n\t\tif (capturedGroupsCount > 0) {\r\n\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t}\r\n\t}\r\n\r\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\r\n\t//\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matchesEntirely(number, national_number_rule) &&\r\n\t// \t!matchesEntirely(nationalSignificantNumber, national_number_rule)) {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return {\r\n   \tnumber: nationalSignificantNumber,\r\n   \tcarrierCode\r\n   }\r\n}\r\n\r\nexport function findCountryCode(callingCode, nationalPhoneNumber, metadata) {\r\n\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\treturn '001'\r\n\t}\r\n\t// Is always non-empty, because `callingCode` is always valid\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn _findCountryCode(possibleCountries, nationalPhoneNumber, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _findCountryCode(possibleCountries, nationalPhoneNumber, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tfor (const country of possibleCountries) {\r\n\t\tmetadata.country(country)\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2) {\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0) {\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\tlet number = extractFormattedPhoneNumber(text, v2)\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = extractExtension(number)\r\n\tif (with_extension_stripped.ext) {\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, national_number, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tformattedPhoneNumber,\r\n\t\tdefaultCountry,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\tlet country\r\n\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tcountry = defaultCountry || (metadata.isNonGeographicCallingCode(defaultCallingCode) ? '001' : undefined)\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst { nationalNumber, carrierCode } = parseNationalNumber(number, metadata)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = findCountryCode(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\tif (country !== '001') {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\nfunction parseNationalNumber(number, metadata) {\r\n\tlet nationalNumber = parseIncompletePhoneNumber(number)\r\n\tlet carrierCode\r\n\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tnumber: potentialNationalNumber,\r\n\t\tcarrierCode: potentialCarrierCode\r\n\t} = stripNationalPrefixAndCarrierCode(nationalNumber, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths()) {\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (checkNumberLengthForType(potentialNationalNumber, undefined, metadata)) {\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t} else {\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potentialNationalNumber, metadata.nationalNumberPattern())) {\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t} else {\r\n\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ countryCallingCode, number }`\r\n// where `number` is just the \"number\" part\r\n// which is left after extracting `countryCallingCode`\r\n// and is not necessarily a \"national (significant) number\"\r\n// and might as well contain national prefix.\r\n//\r\nexport function extractCountryCallingCode(number, country, metadata) {\r\n\tnumber = parseIncompletePhoneNumber(number)\r\n\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, metadata)\r\n\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n"],"file":"parse_.js"}