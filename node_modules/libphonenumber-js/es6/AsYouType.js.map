{"version":3,"sources":["../source/AsYouType.js"],"names":["Metadata","PhoneNumber","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","matchesEntirely","extractCountryCallingCode","extractFormattedPhoneNumber","findCountryCode","stripNationalPrefixAndCarrierCode","FIRST_GROUP_PATTERN","formatNationalNumberUsingFormat","applyInternationalSeparatorStyle","checkNumberLengthForType","parseDigits","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","NATIONAL_PREFIX_SEPARATORS_PATTERN","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_FORMATTED_PHONE_NUMBER_PART","VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN","AsYouType","optionsOrDefaultCountry","metadata","defaultCountry","defaultCallingCode","hasCountry","isNonGeographicCallingCode","reset","formattedOutput","international","undefined","countryCallingCode","digits","nationalNumberDigits","nationalPrefix","carrierCode","setCountry","resetFormat","country","callingCode","selectNumberingPlan","hasSelectedNumberingPlan","initializePhoneNumberFormatsForCountry","matchingFormats","chosenFormat","template","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","text","formattedDigits","extractFormattedDigits","test","getFullNumber","inputDigits","getNonFormattedNationalNumber","extractedNumber","indexOf","slice","length","startInternationalNumber","nextDigits","isInternational","isCountryCallingCodeAmbiguous","determineTheCountry","previousNationalPrefix","extractNationalPrefix","matchFormats","formatNationalNumberWithNextDigits","formattedNumber","attemptToFormatCompletePhoneNumber","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","reformatNationalNumber","format","createFormattingTemplate","formats","filter","internationalFormat","leadingDigits","leadingDigitsPatternIndex","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","nationalPrefixFormattingRule","matcher","pattern","formattedNationalNumber","formattedNationalNumberWithNationalPrefix","getSeparatorAfterNationalPrefix","replace","number","chooseCountryByCountryCallingCode","potentialNationalNumber","index","possibleLengths","isPossibleNumber","nationalNumberPattern","validation_result","countryCodes","getCountryCodesForCallingCode","getTemplateForNumberFormatPattern","match","strictPattern","nationalNumberDummyDigits","numberFormat","getFormatFormat","includesNationalPrefix","numberFormatWithNationalPrefix","i","split","digit","search","cutAndStripNonPairedParens","phoneNumber","getNonFormattedTemplate","stripNonPairedParens","string","dangling_braces","push","pop","start","cleared_string","cutBeforeIndex","closeNonPairedParens","cut_before","retained_template","opening_braces","countOccurences","closing_braces","symbol","count","character","times","result"],"mappings":"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","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n//\r\n// Simplified: does not differentiate between \"local-only\" numbers\r\n// and \"internationally dialable\" numbers.\r\n// For example, doesn't include changes like this:\r\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\n\r\nimport {\r\n\textractCountryCallingCode,\r\n\textractFormattedPhoneNumber,\r\n\tfindCountryCode,\r\n\tstripNationalPrefixAndCarrierCode\r\n} from './parse_'\r\n\r\nimport {\r\n\tFIRST_GROUP_PATTERN,\r\n\tformatNationalNumberUsingFormat,\r\n\tapplyInternationalSeparatorStyle\r\n} from './format_'\r\n\r\nimport { checkNumberLengthForType } from './getNumberType_'\r\n\r\nimport parseDigits from './parseDigits'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_PART + '$', 'i')\r\n\r\nexport default class AsYouType {\r\n\t// Not setting `options` to a constructor argument\r\n\t// not to break backwards compatibility\r\n\t// for older versions of the library.\r\n\toptions = {}\r\n\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (typeof optionsOrDefaultCountry === 'object') {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tthis.defaultCountry = defaultCountry\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\tthis.defaultCountry = '001'\r\n\t\t\t}\r\n\t\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\t}\r\n\t\t// Reset.\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.formattedOutput = ''\r\n\t\tthis.international = undefined\r\n\t\tthis.countryCallingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.nationalNumberDigits = ''\r\n\t\tthis.nationalPrefix = ''\r\n\t\tthis.carrierCode = ''\r\n\t\tthis.setCountry(this.defaultCountry, this.defaultCallingCode)\r\n\t\tthis.resetFormat()\r\n\t\treturn this\r\n\t}\r\n\r\n\tsetCountry(country, callingCode) {\r\n\t\tthis.country = country\r\n\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t} else {\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst formattedDigits = this.extractFormattedDigits(text)\r\n\t\t// If the extracted phone number part\r\n\t\t// can possibly be a part of some valid phone number\r\n\t\t// then parse phone number characters from a formatted phone number.\r\n\t\tif (VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN.test(formattedDigits)) {\r\n\t\t\tthis.formattedOutput = this.getFullNumber(\r\n\t\t\t\tthis.inputDigits(parseDigits(formattedDigits)) ||\r\n\t\t\t\tthis.getNonFormattedNationalNumber()\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts formatted phone number digits from text (if there're any).\r\n\t * @param  {string} text\r\n\t * @return {string}\r\n\t */\r\n\textractFormattedDigits(text) {\r\n\t\t// Extract a formatted phone number part from text.\r\n\t\tlet extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t\t// Special case for a lone '+' sign\r\n\t\t// because it's not extracted in such cases.\r\n\t\tif (!extractedNumber) {\r\n\t\t\tif (text && text.indexOf('+') >= 0) {\r\n\t\t\t\textractedNumber = '+'\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Trim a `+`.\r\n\t\tif (extractedNumber[0] === '+') {\r\n\t\t\t// Trim the `+`.\r\n\t\t\textractedNumber = extractedNumber.slice('+'.length)\r\n\t\t\tif (this.digits) {\r\n\t\t\t\t// If an out of position `+` is detected\r\n\t\t\t\t// (or a second `+`) then just ignore it.\r\n\t\t\t} else {\r\n\t\t\t\tthis.startInternationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn extractedNumber\r\n\t}\r\n\r\n\tstartInternationalNumber() {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.setCountry()\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits) {\r\n\t\t// Append phone number digits.\r\n\t\tthis.digits += nextDigits\r\n\t\t// Try to format the parsed input\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (this.countryCallingCode) {\r\n\t\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t\t// `this.country` could be `undefined`, for example, when there is\r\n\t\t\t\t// ambiguity in a form of several different countries,\r\n\t\t\t\t// each corresponding to the same country phone code\r\n\t\t\t\t// (e.g. NANPA: USA, Canada, etc), and there's not enough digits\r\n\t\t\t\t// to reliably determine the country the phone number belongs to.\r\n\t\t\t\t// Therefore, in cases of such ambiguity, each time something is input,\r\n\t\t\t\t// try to determine the country (if it hasn't been determined yet).\r\n\t\t\t\tif (!this.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\t\t\tthis.determineTheCountry()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Extract country calling code from the digits entered so far.\r\n\t\t\t\t// There must be some digits in order to extract anything from them.\r\n\t\t\t\tif (!this.digits) {\r\n\t\t\t\t\t// Don't format the phone number.\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then they can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\t\t\t\t//\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then don't format the phone number.\r\n\t\t\t\t//\r\n\t\t\t\tif (!this.extractCountryCallingCode()) {\r\n\t\t\t\t\t// Don't format the phone number.\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t// Possibly extract a national prefix.\r\n\t\t\t\t// Some people incorrectly input national prefix\r\n\t\t\t\t// in an international phone number.\r\n\t\t\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t\t\t// Also, mobile phone numbers in Mexico are supposed to be dialled\r\n\t\t\t\t// internationally using a `15` national prefix.\r\n\t\t\t\t//\r\n\t\t\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t\t\t//\r\n\t\t\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t\t\t// it’s necessary to dial an additional “1” after Mexico’s country code\r\n\t\t\t\t// (which is “52”) and before the area code.\r\n\t\t\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t\t\t// cell phone’s number.\r\n\t\t\t\t//\r\n\t\t\t\t// If you don’t add the “1”, you’ll receive a recorded announcement\r\n\t\t\t\t// asking you to redial using it.\r\n\t\t\t\t//\r\n\t\t\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t\t\t// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\r\n\t\t\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t\t\t// from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\r\n\t\t\t\t//\r\n\t\t\t\tthis.nationalNumberDigits = this.digits.slice(this.countryCallingCode.length)\r\n\t\t\t\t// this.extractNationalPrefix()\r\n\t\t\t\t//\r\n\t\t\t\t// Determine the country from country calling code and national number.\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t// If `defaultCallingCode` is set,\r\n\t\t\t// see if the `country` could be derived.\r\n\t\t\tif (!this.country) {\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\t\t\tconst previousNationalPrefix = this.nationalPrefix\r\n\t\t\tthis.nationalNumberDigits = this.nationalPrefix + this.nationalNumberDigits\r\n\t\t\t// Re-extract national prefix.\r\n\t\t\tthis.extractNationalPrefix()\r\n\t\t\t// If another national prefix has been extracted.\r\n\t\t\tif (this.nationalPrefix !== previousNationalPrefix) {\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.nationalNumberDigits) {\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tthis.matchFormats(this.nationalNumberDigits)\r\n\t\t}\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits)\r\n\t}\r\n\r\n\tformatNationalNumberWithNextDigits(nextDigits) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNextNationalNumberDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`.\r\n\t\tconst formattedNumber = this.attemptToFormatCompletePhoneNumber()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone number is invalid,\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attemptToFormatCompletePhoneNumber`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat()\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If could format the next (current) digit\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the formatted number so far.\r\n\t\t\t\t//\r\n\t\t\t\t// If no new phone number format could be chosen,\r\n\t\t\t\t// and couldn't format the supplied national number\r\n\t\t\t\t// using the previously chosen phone number pattern,\r\n\t\t\t\t// then return `undefined`.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then format the national phone number (so far)\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\t//\r\n\t\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t\t// the supplied national number\r\n\t\t\t\t// using the selected phone number pattern.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.reformatNationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tchooseFormat() {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif (!this.createFormattingTemplate(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national phone number entered.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\t// Formats each digit of the national phone number (so far)\r\n\t// using the selected format.\r\n\treformatNationalNumber() {\r\n\t\treturn this.formatNextNationalNumberDigits(\r\n\t\t\tthis.nationalPrefix + this.nationalNumberDigits\r\n\t\t)\r\n\t}\r\n\r\n\tinitializePhoneNumberFormatsForCountry() {\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.matchingFormats = this.metadata.formats().filter((format) => {\r\n\t\t\t// Compared to `libphonenumber`'s code, the two \"Discard a few formats\r\n\t\t\t// that we know are not relevant based on the presence of the national prefix\"\r\n\t\t\t// checks have changed: the first one has been moved to `.matchFormats()`,\r\n\t\t\t// and the second one doesn't apply to this library because it doesn't deal with\r\n\t\t\t// \"incomplete\" phone numbers (for example, phone numbers, entered without \"area code\").\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat())\r\n\t\t})\r\n\t}\r\n\r\n\tmatchFormats(leadingDigits) {\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter((format) => {\r\n\t\t\t// If national prefix is mandatory for this phone number format\r\n\t\t\t// and the user didn't input the national prefix\r\n\t\t\t// then this phone number format isn't suitable.\r\n\t\t\tif (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\t\t\t// If this format is not restricted to a certain\r\n\t\t\t// leading digits pattern then it fits.\r\n\t\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// Start excluding any non-matching formats only when the\r\n\t\t\t// national number entered so far is at least 3 digits long,\r\n\t\t\t// otherwise format matching would give false negatives.\r\n\t\t\t// For example, when the digits entered so far are `2`\r\n\t\t\t// and the leading digits pattern is `21` –\r\n\t\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\r\n\t\t\t// then format matching starts narrowing down the list of possible formats\r\n\t\t\t// (only previously matched formats are considered for next digits).\r\n\t\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\tif (this.metadata.countryCallingCode() === '1') {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// This is in accordance to how Google's `libphonenumber` does it.\r\n\t// \"Check to see if there is an exact pattern match for these digits.\r\n\t// If so, we should use this instead of any other formatting template\r\n\t// whose `leadingDigitsPattern` also matches the input.\"\r\n\tattemptToFormatCompletePhoneNumber() {\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\t\t\tif (!matcher.test(this.nationalNumberDigits)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Here, national number is formatted without \"national prefix\r\n\t\t\t// formatting rule\", because otherwise there'd be a bug\r\n\t\t\t// when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.isInternational(),\r\n\t\t\t\tfalse, // Don't prepend national prefix (it will be prepended manually).\r\n\t\t\t\tthis.metadata\r\n\t\t\t)\r\n\t\t\t// Check if this `format` preserves all digits.\r\n\t\t\t// This is how it's done in Google's `libphonenumber`.\r\n\t\t\t// Also, it fixes the bug when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t//\r\n\t\t\t// \"Check that we didn't remove nor add any extra digits when we matched\r\n\t\t\t// this formatting pattern. This usually happens after we entered the last\r\n\t\t\t// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n\t\t\t// formatted but AYTF should retain all the number entered and not change\r\n\t\t\t// in order to match a format (of same leading digits and length) display\r\n\t\t\t// in that way.\"\r\n\t\t\t// \"If it's the same (i.e entered number and format is same), then it's\r\n\t\t\t// safe to return this in formatted number as nothing is lost / added.\"\r\n\t\t\t// Otherwise, don't use this format.\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n\t\t\t//\r\n\t\t\tif (parseDigits(formattedNationalNumber) !== this.nationalNumberDigits) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Prepend national prefix (if any).\r\n\t\t\tif (this.nationalPrefix) {\r\n\t\t\t\t// Here, national number is formatted with \"national prefix\r\n\t\t\t\t// formatting rule\". The reason is that \"national prefix\r\n\t\t\t\t// formatting rule\" often adds parentheses, and while Google's\r\n\t\t\t\t// `libphonenumber` dismisses those preferring simply prepending\r\n\t\t\t\t// national prefix followed by a \" \" character, this library\r\n\t\t\t\t// looks if the national prefix could be formatted better.\r\n\t\t\t\tconst formattedNationalNumberWithNationalPrefix = formatNationalNumberUsingFormat(\r\n\t\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\tthis.isInternational(),\r\n\t\t\t\t\ttrue, // Prepend national prefix.\r\n\t\t\t\t\tthis.metadata\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(formattedNationalNumberWithNationalPrefix) === this.nationalPrefix + this.nationalNumberDigits) {\r\n\t\t\t\t\tformattedNationalNumber = formattedNationalNumberWithNationalPrefix\r\n\t\t\t\t} else {\r\n\t\t\t\t\tformattedNationalNumber = this.nationalPrefix +\r\n\t\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\t\tformattedNationalNumber\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// formats national number (probably) without national prefix.\r\n\t\t\t// Formatting a national number with national prefix could result in\r\n\t\t\t// bugs when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t// The \"are all digits preserved\" check fixes that type of bug.\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.resetFormat()\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// Set `this.template` and `this.populatedNationalNumberTemplate`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.createFormattingTemplate(format)) {\r\n\t\t\t\t// Populate `this.populatedNationalNumberTemplate` with phone number digits.\r\n\t\t\t\tthis.reformatNationalNumber()\r\n\t\t\t} else {\r\n\t\t\t\t// If the formatting template couldn't be created for a format,\r\n\t\t\t\t// create it manually from the formatted phone number.\r\n\t\t\t\t// This case doesn't ever happen with the current metadata.\r\n\t\t\t\tthis.template = this.getFullNumber(formattedNationalNumber).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.populatedNationalNumberTemplate = formattedNationalNumber\r\n\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.length - 1\r\n\t\t\t}\r\n\t\t\treturn formattedNationalNumber\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn `+${this.digits}`\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn `+${this.countryCallingCode}`\r\n\t\t\t}\r\n\t\t\treturn `+${this.countryCallingCode} ${formattedNationalNumber}`\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumber() {\r\n\t\treturn this.nationalPrefix +\r\n\t\t\t(this.nationalPrefix && this.nationalNumberDigits && this.getSeparatorAfterNationalPrefix()) +\r\n\t\t\tthis.nationalNumberDigits\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textractCountryCallingCode() {\r\n\t\tconst {\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnumber\r\n\t\t} = extractCountryCallingCode(\r\n\t\t\t'+' + this.digits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (!countryCallingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.nationalNumberDigits = number\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.metadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\tthis.resetFormat()\r\n\t\treturn this.metadata.hasSelectedNumberingPlan()\r\n\t}\r\n\r\n\textractNationalPrefix() {\r\n\t\tthis.nationalPrefix = ''\r\n\t\tif (!this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Only strip national prefixes for non-international phone numbers\r\n\t\t// because national prefixes can't be present in international phone numbers.\r\n\t\t// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\r\n\t\tconst {\r\n\t\t\tnumber: potentialNationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = stripNationalPrefixAndCarrierCode(\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\r\n\t\t// Sometimes `stripNationalPrefixAndCarrierCode()` won't actually\r\n\t\t// strip national prefix and will instead prepend some digits to the `number`:\r\n\t\t// for example, when number `2345678` is passed with `VI` country selected,\r\n\t\t// it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n\t\t// So check if the `potentialNationalNumber` is actually at the end of `this.nationalNumberDigits`.\r\n\t\tif (potentialNationalNumber) {\r\n\t\t\tconst index = this.nationalNumberDigits.indexOf(potentialNationalNumber)\r\n\t\t\tif (index < 0 || index !== this.nationalNumberDigits.length - potentialNationalNumber.length) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tthis.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tif (!this.metadata.possibleLengths() ||\r\n\t\t\tthis.isPossibleNumber(this.nationalNumberDigits) &&\r\n\t\t\t!this.isPossibleNumber(potentialNationalNumber)) {\r\n\t\t\t// Verify the parsed national (significant) number for this country\r\n\t\t\t//\r\n\t\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t\t// like `8` is the national prefix for Russia and both\r\n\t\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\t\tif (matchesEntirely(this.nationalNumberDigits, this.metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potentialNationalNumber, this.metadata.nationalNumberPattern())) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.nationalPrefix = this.nationalNumberDigits.slice(0, this.nationalNumberDigits.length - potentialNationalNumber.length)\r\n\t\tthis.nationalNumberDigits = potentialNationalNumber\r\n\t\treturn this.nationalPrefix\r\n\t}\r\n\r\n\tisPossibleNumber(number) {\r\n\t\tconst validation_result = checkNumberLengthForType(number, undefined, this.metadata)\r\n\t\tswitch (validation_result) {\r\n\t\t\tcase 'IS_POSSIBLE':\r\n\t\t\t\treturn true\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\t// \treturn !this.isInternational()\r\n\t\t\tdefault:\r\n\t\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(this.countryCallingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\tcreateFormattingTemplate(format) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tlet template = this.getTemplateForNumberFormatPattern(format, this.nationalPrefix)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.template = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.template = DIGIT_PLACEHOLDER +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t}\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForNumberFormatPattern(format, nationalPrefix) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.nationalNumberDigits.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalNumberDigits : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalNumberDigits`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = this.nationalNumberDigits.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format)\r\n\t\tlet includesNationalPrefix\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(numberFormatWithNationalPrefix) === nationalPrefix + parseDigits(numberFormat)) {\r\n\t\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\t\tincludesNationalPrefix = true\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (!includesNationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\t// Using `.split('')` to iterate through a string here\r\n\t\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t\t// `.split('')` is generally not safe for Unicode,\r\n\t\t// but in this particular case for `digits` it is safe.\r\n\t\t// for (const digit of digits)\r\n\t\tfor (const digit of digits.split('')) {\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\t\t\t// If more digits are entered than the current format could handle.\r\n\t\t\tif (this.populatedNationalNumberTemplate.slice(this.populatedNationalNumberTemplatePosition + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\t\t// Reset the format.\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.populatedNationalNumberTemplate = this.populatedNationalNumberTemplate.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tisInternational() {\r\n\t\treturn this.international\r\n\t}\r\n\r\n\tgetFormatFormat(format) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn applyInternationalSeparatorStyle(format.internationalFormat())\r\n\t\t}\r\n\t\treturn format.format()\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.country = findCountryCode(\r\n\t\t\tthis.isInternational() ? this.countryCallingCode : this.defaultCallingCode,\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!this.country && !this.defaultCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.nationalNumberDigits) {\r\n\t\t\treturn undefined\r\n\t\t}\r\n\t\tconst callingCode = this.countryCallingCode || this.defaultCallingCode\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tthis.country === '001' ? callingCode : this.country || callingCode,\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (this.carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = this.carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.nationalNumberDigits\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\treturn this.getFullNumber(this.getNonFormattedNationalNumber())\r\n\t\t\t.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns formatted phone number template.\r\n\t * @return {string} [template]\r\n\t */\r\n\tgetTemplate() {\r\n\t\tif (!this.template) {\r\n\t\t\treturn this.getNonFormattedTemplate()\r\n\t\t}\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\twhile (i < (this.international ? 1 : 0) + this.digits.length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}"],"file":"AsYouType.js"}